package com.dev.util;


import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;





public class CircuitIdFormatUtil {

	
	
	public static void main(String [] args)
	{
		String standard="DHEC/216550//ATI";
		String icore="DHEC.227179..ATI";
		String bmp=cktidConversion_Icore2Bmp(icore);
		//System.out.println(bmp);
		try {
			 standard=convertFromBMPToStandardFormat(bmp);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println("standardckt "+standard);
		System.out.println("bmp "+bmp);
		System.out.println("icore "+icore);
	//	System.out.println("clci "+standard);
		
		
	}
	
	// ******************************************************/
	// Constant Declarations
	// ******************************************************/

	/* Service Types */
	private static final String SERVICE_TYPES = "STMCXP";

	public static final int INVALID = 0;
	public static final int UNKNOWN = 0;
	public static final int SERIAL = 1;
	public static final int TELEPHONE = 2;
	public static final int MESSAGE = 3;
	public static final int CARRIER = 4;
	public static final int TWOSIX = 5;
	public static final int POTS_CKT = 6;
	public static final int POTS = 7;
	public static final int SL1_CKT = 8;
	public static final int DRYLOOP = 9;

	/* Constants */
	private static final int MIN_SVC_ID_LEN = 8;
	private static final int MAX_SVC_ID_LEN = 53;
	private static final int MAX_NUMBER_FIELDS = 8;
	public static final int TRUNKID_SIZE = 4;

	/* Members */
	private String serviceId = null;
	private boolean unRecognizedFormat = false;
	private int serviceType = 0; // type of circuit: serial, telephone, message,
									// etc.

	/*
	 * The existing logic was that after Routing there would always be a single
	 * Provider to route to so serviceRegion was declared as an int With CR75
	 * after routing via the NPA router we could end up with multiple Providers
	 * leaving the above variable as is(as it work for most cases) introducing a
	 * new variable, if there are multiple providers, then route to multiple
	 * regions (should be merged in the future ??)
	 */
	private int numFields = 0;
	private java.lang.String[] serviceIdFields = new String[MAX_NUMBER_FIELDS];
	
	/**
	 * Constructor for SvcId.
	 */
	public CircuitIdFormatUtil() {
		
	}

	public CircuitIdFormatUtil(String aSvcId) throws Exception {
		if (aSvcId == null || aSvcId.trim().length() < MIN_SVC_ID_LEN || aSvcId.trim().length() > MAX_SVC_ID_LEN) {
			throw new Exception("ServiceId length restrictions: Minimum:8  Maximum: 53");
		}
	}
	
	

	
	

	private static boolean isDigital(String strIn) {
		if (strIn == null || strIn.length() <= 0)
			return false;
		String value = strIn.trim();
		char c;
		for (int i = 0; i < value.length(); i++) {
			c = value.charAt(i);
			if ((c < '0' || c > '9'))
				return false;
		}
		return true;
	}

	
	

	
	

	public static String convertFromBMPToStandardFormat(String args)  {
		StringBuffer bmpFormatCircuidId = null;
		StringBuffer segment = null;
		StringBuffer telecordiaFormatCircuitId = new StringBuffer();
		StringBuffer prefix = new StringBuffer();
		StringBuffer serviceCode = new StringBuffer();
		StringBuffer modifier = new StringBuffer();
		StringBuffer serialNumber = new StringBuffer();
		StringBuffer suffix = new StringBuffer();
		StringBuffer companyCode = new StringBuffer();
		
		/*if ((args == null) || (args.length() == 0)) {
			// Argument missing, throw exception
			throw new InvalidInputException(ExceptionMsg.INVALID_INPUT_CODE, ExceptionMsg.INVALID_INPUT__MSG);
		}
*/
		try {

			/*
			 * If argument length is 1,then only circuit ID is there in the
			 * input If argument length is 2,then only circuit ID is there in
			 * the input
			 */
			if (args != null && args.length()>0) {
				bmpFormatCircuidId = new StringBuffer(args);
			} /*else if (args != null && args.length() == 2) {
				bmpFormatCircuidId = new StringBuffer(args);
				if (args[1] != null && args[1].length() > 0)
					segment = new StringBuffer("/" + args[1].substring(0, args[1].length()));

			}*/

			/*
			 * If BMP Format Circuit ID length is 19 and satisfies all the
			 * conversion rules
			 */

			if (bmpFormatCircuidId != null && bmpFormatCircuidId.length() == 19 && validateBMPFormatCircuit(bmpFormatCircuidId.toString())) {

				prefix = new StringBuffer((bmpFormatCircuidId.substring(0, 2).trim().length() > 0 
						&& bmpFormatCircuidId.substring(0,2).trim().length() < 2) ? padRight(bmpFormatCircuidId.substring(0, 2).trim(), 2, "0") : bmpFormatCircuidId.substring(0, 2).trim());

				serviceCode = new StringBuffer((prefix != null && prefix.length() > 0) ? "/" + bmpFormatCircuidId.substring(2, 4).trim(): bmpFormatCircuidId.substring(2, 4).trim());

				modifier = new StringBuffer(bmpFormatCircuidId.substring(4, 6).trim());

				serialNumber = new StringBuffer("/"	+ bmpFormatCircuidId.substring(6, 12).trim());

				String tempSuffix = bmpFormatCircuidId.substring(12, 15).trim();
				while (tempSuffix.startsWith("0")) {
					tempSuffix = tempSuffix.substring(1);

				}
				suffix = new StringBuffer("/" + tempSuffix);

				companyCode = new StringBuffer("/" + bmpFormatCircuidId.substring(15, 19).trim());

				telecordiaFormatCircuitId.append(prefix).append(serviceCode).append(modifier).append(serialNumber).append(suffix).append(companyCode);

				/*if (segment != null)
					telecordiaFormatCircuitId.append(segment);*/
			} else {
				telecordiaFormatCircuitId = bmpFormatCircuidId;
			}

		} catch (Exception e) {
			throw e;
		}
	//	System.out.println("TelcordiaFormat/CLCI Format:"+telecordiaFormatCircuitId.toString());
		return telecordiaFormatCircuitId.toString();
	}



	

	private static boolean validateBMPFormatCircuit(String bmpFormatCircuidId) {
		
		if(isAlphaNumeric(bmpFormatCircuidId.substring(0, 2)) && isAlphaNumeric(bmpFormatCircuidId.substring(2, 4)) && isDigital(bmpFormatCircuidId.substring(6,12))
			&&isAlphaNumeric(bmpFormatCircuidId.substring(12, 15)) && isAlphaNumeric(bmpFormatCircuidId.substring(15, 19))) 
		
			return true;
		else
			
			return false;
		
	}


	/**
	* @param String 
	* @return boolean - whether input is alpha numeric or not
	* Method Written on 11/22/2013 for 259083a Feb'13 project by Manikandan(mm103e)
	*/
	
	public static boolean isAlphaNumeric(String strIn) {
		if (strIn == null)
			return false;
		String value = strIn.trim();
		char c;
		for (int i = 0; i < value.length(); i++) {
			c = value.charAt(i);
			if (!((c >= '0' && c <= '9') || c == ' ' || (c>= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))
				return false;
		}
		return true;
	}
	
	/*public static void main (String args[]){
		CircuitIdFormatUtil c= new CircuitIdFormatUtil();
		String cktId1="  DHEC709504814ATI ";
		String cktId2="43/HFGM/000169    /SUV ";
		try {
			if(c.validateCLCIFormat(cktId2)){
				System.out.println("It is in CLCI format");
			}else{
				System.out.println("It is not in CLCI format");
				String bmpFormat=c.cktidConversion_Icore2Bmp(cktId2);
				String covertedCLCI=c.convertFromBMPToStandardFormat(bmpFormat);
				c.validateCLCIFormat(covertedCLCI);
				
			}
			//c.validateCLCIFormat(cktId2);
			//c.convertFromWFACToStandardFormat(cktId2);
			//c.convertFromBMPToStandardFormat(cktId1);
			//c.convertToBMPFormat(cktId2);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}*/
	
	private static String padRight(String input, int length, String pad) {
		// TODO Auto-generated method stub

		String output;

		output = input;
		while (output.length() < length) {
			output = pad + output;
		}
		return output;
	}
	
	

	
	public boolean isAlphabetic(String strIn) {
		if (strIn == null)
			return false;
		String value = strIn.trim();
		char c;
		for (int i = 0; i < value.length(); i++) {
			c = value.charAt(i);
			if (!( c == ' ' || (c>= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))
				return false;
		}
		return true;
	}
	
	
	public static  boolean validateCLCIFormat(String circuitId){
		// String REGEX = "([0-9,a-z,A-Z]{0,2}/)*([a-z,A-Z]{2,4}/)+([0-9]{1,6}/)+([a-z,A-Z,0-9]{3})*/([a-z,A-Z]{2,4})+([0-9,a-z,A-Z]{0,3})*";
		 boolean isCLCI=false;
		 String prefix="([0-9,a-z,A-Z]{0,2}/)*";
		 String serviceCodeAndModifier="([a-z,A-Z]{2,4}/)+";
		 String serialNumber="([0-9]{1,6}/)+";
		 String suffix="([a-z,A-Z,0-9]{3})*/";
		 String CompanyCode="([a-z,A-Z]{2,4})+";
		 String Segement="(/[a-z,A-Z,0-9]{0,3})*";
		 
		 String clciRegex=prefix+serviceCodeAndModifier+serialNumber+suffix+CompanyCode+Segement;
	
	     Pattern pattern;
	     Matcher matcher;

	   
	       pattern = Pattern.compile(clciRegex);
	       matcher = pattern.matcher(circuitId);


	       
	  //     System.out.println("matches(): "+matcher.matches());
	    /*   if(matcher.matches()){
	    	   System.out.println("Input"+circuitId+" is in CLCI format");
	       }*/
	       isCLCI=matcher.matches();
	       return isCLCI;
	}
	
	
public static  String cktidConversion_Icore2Bmp(String inputCktId)
    
    {
      String returnCkt = "";
      StringTokenizer strToken = null;
      String subToken = null;
      StringBuffer buf = null;
      boolean containsdot = false;
      boolean containsslash = false;
      char[] cktIdcharArray =  inputCktId.toCharArray();      
      
      //Check for Dot or Slash format
      for(int i=0; i<cktIdcharArray.length;i++){
            String check = cktIdcharArray[i]+"";
            //check for dot delimiter
            if(check.equals(".")){            
                containsdot = true;
                containsslash = false;
                break;
            //check for slash delimiter
            }else if(check.equals("/")){            
                containsslash = true;
                containsdot = false;
                break;
            }             
      }      
      //if input CircuitID contains dot delimiter      
      if(containsdot){
          if(".".equals(inputCktId.substring(2,3))){
           // try{
                strToken = new StringTokenizer(inputCktId.trim(), ".");
                int j = strToken.countTokens();
                if(j == 4 || j == 5) {
                  buf = new StringBuffer();
                  int i=0;
                  while (strToken.hasMoreTokens()) {
                    if (i == 0) {//get prefix
                        buf.append(checkForLeadingZero(strToken.nextToken().trim()));
                    }else if(i == 1){//get svcmod
                        buf.append(strToken.nextToken().trim());
                    }else if(i == 2){//get serno
                        buf.append(convertZerosToSpaces(strToken.nextToken().trim()));
                    }else if(i == 3){//get Suffix
                        if (inputCktId.trim().length() > 19) {
                            subToken = strToken.nextToken().trim();
                            if (subToken == null || subToken.equals("")) {
                                buf.append("   ");
                            }
                            else if (subToken.length() > 0 && subToken.length() < 3) {
                                int k = 0;
                                while (k < 3 - subToken.length()) {
                                    buf.append("0");
                                    k++;
                                }
                                buf.append(subToken);
                            }
                            else {
                                buf.append(subToken);
                            }
                        }else {
                            buf.append("   " + checkSpacesForCO(strToken.nextToken()));
                        }
                    }else if(i == 4){//get co
                        buf.append(checkSpacesForCO(strToken.nextToken()));
                    }
                    i++;  
                  }
                  returnCkt = buf.toString();
                }
              /*}catch (Exception e) {
                    e.printStackTrace();
                    throw new Exception(e.toString());
              } */        
          }else{
            //  try {
                strToken = new StringTokenizer(inputCktId.trim(), ".");
                int j = strToken.countTokens();
                if(j == 3 || j == 4) {
                  buf = new StringBuffer();
                  int i=0;
                  while (strToken.hasMoreTokens()) {
                    // get circuitID prefix (2 char), and ServiceCode (4 char)
                    if (i == 0) {
                        buf.append("  " + strToken.nextToken().trim());
                    }
                    // get circuitID serialNumber (6 digit).
                    // If less than 6 digit, padded with Leading blanks
                    else if (i == 1) {
                        subToken = strToken.nextToken().trim();
                        if (subToken.length() > 0 && subToken.length() < 6) {
                            int k = 0;
                            while (k < 6 - subToken.length()) {
                                buf.append(" ");
                                k++;
                            }
                        }
                        buf.append(subToken);
                    }
                    // get circuitID suffix (3 digit or blank).
                    // If less than 3 digit, padded with leading spaces
                    // If it's blank, padded with blanks
                    else if (i == 2) {
                        // if the input cktId has suffix, get it
                        // else, get the company code directly
                        if (inputCktId.trim().length() > 16) {

                            subToken = strToken.nextToken().trim();
                            if (subToken == null || subToken.equals("")) {
                                buf.append("   ");
                            }
                            else if (subToken.length() > 0 && subToken.length() < 3) {
                                int k = 0;
                                while (k < 3 - subToken.length()) {
                                    buf.append("0");
                                    k++;
                                }
                                buf.append(subToken);
                            }
                            else {
                                buf.append(subToken);
                            }
                        }
                        else {
                            buf.append("   " + checkSpacesForCO(strToken.nextToken()));
                        }
                    }
                    // get circuitID CompanyCode (4 char).
                    else if (i == 3 ) {
                        buf.append(checkSpacesForCO(strToken.nextToken()));
                    }
                    i++;
                  }
                  returnCkt = buf.toString();
                }
                else
                    returnCkt = inputCktId.trim();
           /*   }
              catch (Exception e) {
                    e.printStackTrace();
                    throw new Exception(e.toString());
              }*/
          }
      }else if(containsslash){    //if input CircuitID contains / delimiter
            strToken = new StringTokenizer(inputCktId.trim(), "/");
            String formattedcktid = "";
            while(strToken.hasMoreTokens()){
                formattedcktid = formattedcktid+strToken.nextToken();
            }
            returnCkt = formattedcktid;
      }else{
         returnCkt = inputCktId.trim();
      }
   //   System.out.println("BMPFormat:"+cktidConversionZeroToSpaces(returnCkt));
      return cktidConversionZeroToSpaces(returnCkt); 
      
   }

public static String checkForLeadingZero(String inputCktId){
    
    String prefixFirstPart = inputCktId.substring(0, 1);
    String prefixSecondPart = inputCktId.substring(1, 2);
    String prefix = "";
    if("0".equals(prefixFirstPart)){
        prefix = prefixSecondPart+" ";
    }else{
        prefix = inputCktId;
    }     
    return prefix;
}

public static String cktidConversionZeroToSpaces(String inputCktId){
   
 String middlePart = inputCktId.substring(6,12);
 String newMiddlePart = "";
 char[] cktIdcharArray =  middlePart.toCharArray();
 for(int i = 0; i<cktIdcharArray.length; i++){             
     if(cktIdcharArray[i] == '0'){
         newMiddlePart = newMiddlePart+" ";                 
     }else{                 
         newMiddlePart = newMiddlePart+middlePart.substring(i,middlePart.length());
         break;
     }
 }
 String firstPart = inputCktId.substring(0,6);
 String lastPart = inputCktId.substring(12,inputCktId.length());
 String returnCkt = firstPart + newMiddlePart + lastPart;
 return returnCkt;    

}   
public static String convertZerosToSpaces(String inputCktId){
    String newMiddlePart = "";
    char[] cktIdcharArray =  inputCktId.toCharArray();
    for(int i = 0; i<cktIdcharArray.length; i++){
        if(cktIdcharArray[i] == '0'){
            newMiddlePart = newMiddlePart+" ";
        }else{
            newMiddlePart = newMiddlePart+inputCktId.substring(i,inputCktId.length());
            break;
        }
    }
    return newMiddlePart;
}
public static String checkSpacesForCO(String inputCktId){
    
    int cktlen = inputCktId.length();
    if( cktlen < 4 ){
        for(int i = 0; i <= 4; i++){
            inputCktId = inputCktId+" ";
            cktlen++;
            if(cktlen == 4){
                break;
            }                        
        }
    }
    return inputCktId;        
}

public static String  convertToCLCIFormat(String assetIdentifierValue) {

	String CLCICircuitId=null;
	String BMPCircuit=null;
	try{
	if(validateBMPFormatCircuit(assetIdentifierValue)){
		CLCICircuitId =convertFromBMPToStandardFormat(assetIdentifierValue);
		//System.out.println("Circuit Id after conversion from BMP is"+CLCICircuitId);
		
	}
	else{
	
	BMPCircuit =cktidConversion_Icore2Bmp(assetIdentifierValue);
	CLCICircuitId=convertFromBMPToStandardFormat(BMPCircuit);
	}
	if(validateCLCIFormat(CLCICircuitId)){
		System.out.println("Conversion to CLCI successfull");
		return CLCICircuitId;
	}
	
	}catch(Exception e){
		System.out.println("Exception occured while checking if convertible to CLCLI or not!!!");
	}
	
	return null;
}
}
